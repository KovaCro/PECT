from pathlib import Path
from collections.abc import Callable
from functools import partial
import multiprocessing
from concurrent.futures import ProcessPoolExecutor
import inspect
from tqdm import tqdm
import pect


def process_single_problem(
    index: int,
    input_path: str,
    solver: Callable[[pect.Pectp], pect.Pects],
    solver_kwargs: dict,
    solver_type: str,
    output_dir: Path,
) -> None:
    """ Helper function to process a single problem. """
    input_path = Path(input_path)
    problem = pect.parse_problem(input_path)
    fails = []
    solution = solver(problem, **solver_kwargs)
    is_valid = pect.is_valid(problem, solution, fails)
    if not is_valid:
        print(f"Solution {index} generated by {solver_type} is invalid")
        print(fails)
    evaluation = pect.evaluate(problem, solution)
    output_path = output_dir / input_path.stem
    pect.write_formatted_solution(
        output_path.with_suffix(".formatted.sln"), problem, solution
    )
    pect.write_solution(output_path.with_suffix(".sln"), solution)
    pect.write_evaluation(output_path.with_suffix(".eval"), evaluation)


def map_process(args, solver, solver_kwargs, solver_type, output_dir):
    """ Helper function to unpack arguments and call process_single_problem. """
    index, input_path = args
    process_single_problem(
        index, input_path, solver, solver_kwargs, solver_type, output_dir
    )


def generate_and_evaluate_solutions(
    input_paths: list[Path],
    output_dir: Path,
    solver: Callable[[pect.Pectp], pect.Pects],
    solver_kwargs: dict = {},
    max_workers: int = None,
) -> None:
    """
    Uses solver to generate solutions and writes solutions
    to a directory toggether with solution evaluations.

    Args:
        input_paths: list of paths to problems
        output_dir: path to output directory
        solver: function used to generate solution
        solver_kwargs: solver arguments
        max_workers: number of threads
    """

    output_dir.mkdir(parents=True, exist_ok=True)

    solver_type = inspect.getmodule(solver).__name__

    if max_workers is None:
        max_workers = multiprocessing.cpu_count()

    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        # Convert Path objects to strings to avoid pickling issues
        list(
            tqdm(
                executor.map(
                    partial(
                        map_process,
                        solver=solver,
                        solver_kwargs=solver_kwargs,
                        solver_type=solver_type,
                        output_dir=output_dir,
                    ),
                    enumerate(str(path) for path in input_paths),
                ),
                total=len(input_paths),
                desc=f"Generating {solver_type} solutions",
                position=0,
            )
        )

    pect.generate_evaluation_csv(output_dir)
