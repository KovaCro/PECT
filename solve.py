from pathlib import Path
from collections.abc import Callable
from functools import partial
import multiprocessing
from concurrent.futures import ProcessPoolExecutor
import inspect
from tqdm import tqdm
import pect
from parsers import ProblemParser, SolutionParser, EvaluationParser, EvaluationCsvGenerator

problem_parser = ProblemParser()
solution_parser = SolutionParser()
evaluation_parser = EvaluationParser()
csv_generator = EvaluationCsvGenerator()


def process_single_problem(
    index: int,
    input_path: str,
    solver: Callable[[pect.Pectp], pect.Pects],
    solver_kwargs: dict,
    solver_type: str,
    output_dir: Path,
) -> None:
    """ Helper function to process a single problem. """
    input_path = Path(input_path)
    problem = problem_parser.read(input_path)
    fails = []
    solution = solver(problem, **solver_kwargs)
    is_valid = pect.is_valid(problem, solution, fails)
    if not is_valid:
        print(f"Solution {index} generated by {solver_type} is invalid")
        print(fails)
    evaluation = pect.evaluate(problem, solution)
    output_path = output_dir / input_path.stem
    solution_parser.write_formatted_solution(output_path.with_suffix(".formatted.sln"), problem, solution)
    solution_parser.write(output_path.with_suffix(".sln"), solution)
    evaluation_parser.write(output_path.with_suffix(".eval"), evaluation)


def map_process(args, solver, solver_kwargs, solver_type, output_dir):
    """ Helper function to unpack arguments and call process_single_problem. """
    index, input_path = args
    process_single_problem(
        index, input_path, solver, solver_kwargs, solver_type, output_dir
    )


def generate_and_evaluate_solutions(
    input_paths: list[Path],
    output_dir: Path,
    solver: Callable[[pect.Pectp], pect.Pects],
    solver_kwargs: dict = {},
    max_workers: int = None,
) -> None:
    """
    Uses solver to generate solutions and writes solutions
    to a directory toggether with solution evaluations.

    Args:
        input_paths: list of paths to problems
        output_dir: path to output directory
        solver: function used to generate solution
        solver_kwargs: solver arguments
        max_workers: number of threads
    """

    output_dir.mkdir(parents=True, exist_ok=True)

    solver_type = inspect.getmodule(solver).__name__

    if max_workers is None:
        max_workers = multiprocessing.cpu_count()

    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        # Convert Path objects to strings to avoid pickling issues
        list(
            tqdm(
                executor.map(
                    partial(
                        map_process,
                        solver=solver,
                        solver_kwargs=solver_kwargs,
                        solver_type=solver_type,
                        output_dir=output_dir,
                    ),
                    enumerate(str(path) for path in input_paths),
                ),
                total=len(input_paths),
                desc=f"Generating {solver_type} solutions",
                position=0,
            )
        )

    csv_generator.generate_evaluation_csv(output_dir)
